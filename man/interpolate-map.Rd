% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpMap.R
\name{krigingMap}
\alias{krigingMap}
\alias{voronoiMap}
\title{Spatially interpolated dynamic and static maps}
\usage{
krigingMap(
  data,
  pollutant = NULL,
  statistic = "mean",
  percentile = 95,
  newdata = NULL,
  method = c("idw", "kriging"),
  breaks = NULL,
  labels = NULL,
  limits = NULL,
  latitude = NULL,
  longitude = NULL,
  crs = 4326,
  provider = "OpenStreetMap",
  cols = "turbo",
  alpha = 0.8,
  show.markers = TRUE,
  marker.border = "white",
  legend = TRUE,
  legend.position = NULL,
  legend.title = NULL,
  legend.title.autotext = TRUE,
  static = FALSE,
  vgm = gstat::vgm(psill = 1, model = "Exp", range = 50000, nugget = 1),
  args.idw = list(),
  args.variogram = list(),
  args.fit.variogram = list(),
  args.krige = list()
)

voronoiMap(
  data,
  pollutant = NULL,
  statistic = "mean",
  percentile = 95,
  newdata = NULL,
  breaks = NULL,
  labels = NULL,
  limits = NULL,
  latitude = NULL,
  longitude = NULL,
  crs = 4326,
  provider = "OpenStreetMap",
  cols = "turbo",
  alpha = 0.8,
  show.markers = TRUE,
  marker.border = "white",
  voronoi.border = "white",
  legend = TRUE,
  legend.position = NULL,
  legend.title = NULL,
  legend.title.autotext = TRUE,
  static = FALSE,
  args.voronoi = list()
)
}
\arguments{
\item{data}{\emph{Input data table with pollutant and geo-spatial information.}

\strong{required} | \emph{scope:} dynamic & static

A data frame. The data frame must contain at least one numeric column to
interpolate, plus a decimal latitude and longitude (or X/Y coordinate used
in conjunction with \code{crs}).}

\item{pollutant}{\emph{Pollutant name.}

\strong{required} | \emph{scope:} dynamic & static

The column name of the pollutant to plot. Multiple \code{pollutants} are
prohibited by this function.}

\item{statistic}{\emph{Statistic for aggregating pollutant data.}

\emph{default:} \code{"mean"} | \emph{scope:} dynamic & static

Pollutant data will be aggregated by latitude & longitude; \code{statistic}
controls how this is achieved. Possible statistics include:
\itemize{
\item \code{"mean"}: the arithmetic mean (using \code{\link[=mean]{mean()}})
\item \code{"median"}: the median (middle) value (using \code{\link[stats:median]{stats::median()}})
\item \code{"max"}: the maximum value (using \code{\link[=max]{max()}})
\item \code{"min"}: the maximum value (using \code{\link[=min]{min()}})
\item \code{"sd"}: the standard deviation (using \code{\link[stats:sd]{stats::sd()}})
\item \code{"percentile"}: a percentile value, defined using the \code{percentile} argument (using \code{\link[stats:quantile]{stats::quantile()}})
}}

\item{percentile}{\emph{The percentile when `statistic = "percentile"}

\emph{default:} \code{95} | \emph{scope:} dynamic & static

The percentile level used when \code{statistic = "percentile"}. The default is
\code{95}, representing 95\%. Should be between \code{0} and \code{100}.}

\item{newdata}{\emph{A spatial dataset of prediction locations.}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

By default, a bounding box of all latitudes and longitudes are used for
prediction, but this is often not useful or aesthetically pleasing.
\code{newdata} should be a spatial data frame (constructed with
\code{\link[sf:st_as_sf]{sf::st_as_sf()}}). This may be a country or authority boundary relevant to
the \code{data} input.}

\item{method}{\emph{Spatial interpolation method.}

\emph{default:} \code{"idw"} | \emph{scope:} dynamic & static

The spatial interpolation method to use for \code{\link[=krigingMap]{krigingMap()}}. \code{"idw"} uses
inverse distance weighting (IDW) which is simpler and faster. \code{"kriging"}
uses full point kriging which is typically more accurate, but is also more
complex and computationally intensive.}

\item{labels, breaks}{\emph{Discretise the map color scale.}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

By default, a continuous colour scale is used. If \code{breaks} are provided,
the colour scale will be discretised using \code{\link[=cut]{cut()}}. \code{labels} can also be
provided to customise how each factor level is labelled.}

\item{limits}{\emph{Specifier for the plot colour scale bounds.}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

A numeric vector in the form \code{c(lower, upper)} used to define the colour
scale. For example, \code{limits = c(0, 100)} would force the plot limits to
span 0-100. If \code{NULL}, appropriate limits will be selected based on the
range in \code{data[[pollutant]]}.}

\item{latitude, longitude}{\emph{The decimal latitude(Y)/longitude(X).}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

Column names representing the decimal latitude and longitude (or other Y/X
coordinate if using a different \code{crs}). If not provided, will be
automatically inferred from data by looking for a column named
"lat"/"latitude" or "lon"/"lng"/"long"/"longitude" (case-insensitively).}

\item{crs}{\emph{The coordinate reference system (CRS).}

\emph{default:} \code{4326} | \emph{scope:} dynamic & static

The coordinate reference system (CRS) of the data, passed to
\code{\link[sf:st_crs]{sf::st_crs()}}. By default this is \href{https://epsg.io/4326}{EPSG:4326}, the
CRS associated with the commonly used latitude and longitude coordinates.
Different coordinate systems can be specified using \code{crs} (e.g., \code{crs = 27700} for the \href{https://epsg.io/27700}{British National Grid}). Note that
non-lat/lng coordinate systems will be re-projected to EPSG:4326 for
plotting on the map.}

\item{provider}{\emph{The basemap(s) to be used.}

\emph{default:} \code{"OpenStreetMap"} | \emph{scope:} dynamic & static

The base map(s) to be used for the map. If not provided, will default to
\code{"OpenStreetMap"}/\code{"osm"} for both dynamic and static maps.
\itemize{
\item \emph{Dynamic}: Any number of \link[leaflet:providers]{leaflet::providers}.
See \url{http://leaflet-extras.github.io/leaflet-providers/preview/} for a list
of all base maps that can be used. If multiple base maps are provided, they
can be toggled between using a "layer control" interface. By default, the
interface will use the provider names as labels, but users can define their
own using a named vector (e.g., \code{c("Default" = "OpenStreetMap", "Satellite"   = "Esri.WorldImagery")})
\item \emph{Static}: One of \code{\link[rosm:deprecated]{rosm::osm.types()}}.
}

There is some overlap in static and dynamic providers. For example,
\code{{ggspatial}} uses "osm" to specify "OpenStreetMap". When static providers
are provided to dynamic maps or vice versa, \code{{openairmaps}} will attempt to
substitute the correct provider string.}

\item{cols}{\emph{Colours to use for plotting.}

\emph{default:} \code{"turbo"} | \emph{scope:} dynamic & static

The colours used for plotting, passed to \code{\link[openair:openColours]{openair::openColours()}}. The
default, \code{"turbo"}, is a rainbow palette with relatively perceptually
uniform colours.}

\item{alpha}{\emph{Transparency value for interpolated surface.}

\emph{default:} \code{1} | \emph{scope:} dynamic & static

A value between 0 (fully transparent) and 1 (fully opaque).}

\item{show.markers}{\emph{Show original monitoring site markers?}

\emph{default:} \code{TRUE} | \emph{scope:} dynamic & static

When \code{TRUE}, the coordinates in the input \code{data} will be shown as coloured
markers.}

\item{marker.border, voronoi.border}{\emph{Border colour to use for markers and
voronoi tiles.}

\emph{default:} \code{"white"} | \emph{scope:} dynamic & static

Any valid HTML colour (e.g., a hex code). Use \code{NA} for no border.}

\item{legend}{\emph{Draw a legend?}

\emph{default:} \code{TRUE} | \emph{scope:} dynamic & static

When \code{TRUE}, a legend will appear on the map identifying the colour scale.}

\item{legend.position}{\emph{Position of the shared legend.}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

When \code{legend = TRUE}, where should the legend be placed?
\itemize{
\item \emph{Dynamic}: One of "topright", "topright", "bottomleft" or "bottomright". Passed to the \code{position} argument of \code{\link[leaflet:addLegend]{leaflet::addLegend()}}.
\item \emph{Static:}: One of "top", "right", "bottom" or "left". Passed to the \code{legend.position} argument of \code{\link[ggplot2:theme]{ggplot2::theme()}}.
}}

\item{legend.title}{\emph{Title of the legend.}

\emph{default:} \code{NULL} | \emph{scope:} dynamic & static

By default, when \code{legend.title = NULL}, the function will attempt to
provide a sensible legend title. \code{legend.title} allows users to overwrite
this - for example, to include units or other contextual information. For
\emph{dynamic} maps, users may wish to use HTML tags to format the title.}

\item{legend.title.autotext}{\emph{Automatically format the title of the legend?}

\emph{default:} \code{TRUE} | \emph{scope:} dynamic & static

When \code{legend.title.autotext = TRUE}, \code{legend.title} will be first run
through \code{\link[=quickTextHTML]{quickTextHTML()}} (\emph{dynamic}) or \code{\link[openair:quickText]{openair::quickText()}} (\emph{static}).}

\item{static}{\emph{Produce a static map?}

\emph{default:} \code{FALSE}

This controls whether a \emph{dynamic} or \emph{static} map is produced. The former
is the default and is broadly more useful, but the latter may be preferable
for DOCX or PDF outputs (e.g., academic papers).}

\item{vgm}{\emph{A variogram model}

\emph{default:} \code{gstat::vgm(psill = 1, model = "Exp", range = 50000, nugget = 1)} | \emph{scope:} dynamic & static

The variogram model to use when \code{method = "kriging"}. Must be the output of
\code{\link[gstat:vgm]{gstat::vgm()}}.}

\item{args.idw, args.variogram, args.fit.variogram, args.krige}{\emph{Extra arguments
to pass to spatial interpolation functions for \code{\link[=krigingMap]{krigingMap()}}.}

\emph{scope:} dynamic & static

Extra arguments passed to \code{\link[gstat:krige]{gstat::idw()}}, \code{\link[gstat:vgm]{gstat::vgm()}},
\code{\link[gstat:fit.variogram]{gstat::fit.variogram()}}, and \code{\link[gstat:krige]{gstat::krige()}}.}

\item{args.voronoi}{\emph{Extra arguments to pass to spatial interpolation
functions for \code{\link[=voronoiMap]{voronoiMap()}}.}

\emph{scope:} dynamic & static

Extra arguments passed to \code{\link[terra:voronoi]{terra::voronoi()}}, with the exception of \code{x}
which is dealt with by \code{\link[=voronoiMap]{voronoiMap()}}.}
}
\value{
Either:
\itemize{
\item \emph{Dynamic:} A leaflet object
\item \emph{Static:} A \code{ggplot2} object using \code{\link[ggplot2:ggsf]{ggplot2::coord_sf()}} coordinates with a \code{ggspatial} basemap
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

These functions create interpolated surfaces out of data at individual
monitoring sites. This can be useful to 'fill in the gaps' to estimate
pollution concentrations where no monitoring is occurring, or better
identify geographical patterns in pollution data. \code{\link[=krigingMap]{krigingMap()}} creates a
smooth spatially interpolated surface using either inverse distance
weighting or point kriging. \code{\link[=voronoiMap]{voronoiMap()}} creates a surface of 'closest
observation' polygons. The kriging formula is currently always \code{pollutant ~ 1}; \code{\link[=krigingMap]{krigingMap()}} does not currently support more complex models.
}
\examples{
\dontrun{
# import ozone DAQI
daqi <-
  openair::importUKAQ(
    pollutant = "o3",
    year = 2020,
    source = "aurn",
    data_type = "daqi",
    meta = TRUE
  )

# get a UK shapefile
uk <- rnaturalearth::ne_countries(scale = 10, country = "united kingdom")

# create spatially interpolated map
voronoiMap(
  daqi,
  pollutant = "poll_index",
  newdata = uk,
  statistic = "max",
  breaks = seq(0.5, 10.5, 1),
  labels = as.character(1:10),
  legend.title = "Max O3 DAQI",
  cols = "daqi"
)

krigingMap(
  daqi,
  pollutant = "poll_index",
  newdata = uk,
  statistic = "max",
  legend.title = "Max O3 DAQI",
  cols = openair::openColours("daqi", n = 10),
  limits = c(1, 10)
)
}

}
\concept{spatial interpolation maps}
